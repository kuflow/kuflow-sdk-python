# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.9.3, generator: @autorest/python@6.2.9)
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from typing import Any, AsyncIterator, Callable, Dict, IO, List, Optional, TypeVar, Union, overload

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict

from ... import models as _models
from ..._operations._ku_flow_client_operations import (
    build_actions_process_cancel_request,
    build_actions_process_change_initiator_request,
    build_actions_process_complete_request,
    build_actions_process_delete_element_request,
    build_actions_process_save_element_request,
    build_actions_process_save_user_action_value_document_request,
    build_actions_task_append_log_request,
    build_actions_task_assign_request,
    build_actions_task_claim_request,
    build_actions_task_complete_request,
    build_actions_task_delete_element_request,
    build_actions_task_delete_element_value_document_request,
    build_actions_task_download_element_value_document_request,
    build_actions_task_download_element_value_rendered_request,
    build_actions_task_save_element_request,
    build_actions_task_save_element_value_document_request,
    build_create_authentication_request,
    build_create_process_request,
    build_create_task_request,
    build_find_principals_request,
    build_find_processes_request,
    build_find_tasks_request,
    build_request_echo_request,
    build_retrieve_principal_request,
    build_retrieve_process_request,
    build_retrieve_task_request,
)
from .._vendor import KuFlowClientMixinABC

T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]


class KuFlowClientOperationsMixin(KuFlowClientMixinABC):  # pylint: disable=too-many-public-methods
    @distributed_trace_async
    async def request_echo(self, **kwargs: Any) -> _models.Authentication:
        """Echo endpoint to test integration, return a DUMMY authentication token.

        Echo endpoint to test integration, return a DUMMY authentication token.

        :return: Authentication
        :rtype: ~kuflow.client.models.Authentication
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Authentication] = kwargs.pop("cls", None)

        request = build_request_echo_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.DefaultError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Authentication", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def create_authentication(
        self, authentication: _models.Authentication, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Authentication:
        """Create an authentication for the current principal.

        Create an authentication for the current principal.

        :param authentication: Authentication to be created. Required.
        :type authentication: ~kuflow.client.models.Authentication
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Authentication
        :rtype: ~kuflow.client.models.Authentication
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_authentication(
        self, authentication: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Authentication:
        """Create an authentication for the current principal.

        Create an authentication for the current principal.

        :param authentication: Authentication to be created. Required.
        :type authentication: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Authentication
        :rtype: ~kuflow.client.models.Authentication
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_authentication(
        self, authentication: Union[_models.Authentication, IO], **kwargs: Any
    ) -> _models.Authentication:
        """Create an authentication for the current principal.

        Create an authentication for the current principal.

        :param authentication: Authentication to be created. Is either a model type or a IO type.
         Required.
        :type authentication: ~kuflow.client.models.Authentication or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: Authentication
        :rtype: ~kuflow.client.models.Authentication
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Authentication] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(authentication, (IO, bytes)):
            _content = authentication
        else:
            _json = self._serialize.body(authentication, "Authentication")

        request = build_create_authentication_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.DefaultError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Authentication", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def find_principals(
        self,
        *,
        size: int = 25,
        page: int = 0,
        sort: Optional[List[str]] = None,
        type: Optional[Union[str, _models.PrincipalType]] = None,
        group_id: Optional[List[str]] = None,
        **kwargs: Any
    ) -> _models.PrincipalPage:
        """Find all accessible Principals.

        List all the Principals that have been created and the used credentials has access.

        Available sort query values: id, name.

        :keyword size: The number of records returned within a single API call. Default value is 25.
        :paramtype size: int
        :keyword page: The page number of the current page in the returned records, 0 is the first
         page. Default value is 0.
        :paramtype page: int
        :keyword sort: Sorting criteria in the format: property{,asc|desc}. Example: createdAt,desc

         Default sort order is ascending. Multiple sort criteria are supported.

         Please refer to the method description for supported properties. Default value is None.
        :paramtype sort: list[str]
        :keyword type: Filter principals by type. Known values are: "USER", "APPLICATION", and
         "SYSTEM". Default value is None.
        :paramtype type: str or ~kuflow.client.models.PrincipalType
        :keyword group_id: Filter principals that exists in one of group ids. Default value is None.
        :paramtype group_id: list[str]
        :return: PrincipalPage
        :rtype: ~kuflow.client.models.PrincipalPage
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PrincipalPage] = kwargs.pop("cls", None)

        request = build_find_principals_request(
            size=size,
            page=page,
            sort=sort,
            type=type,
            group_id=group_id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.DefaultError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("PrincipalPage", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def retrieve_principal(self, id: str, **kwargs: Any) -> _models.Principal:
        """Get a Principal by ID.

        Returns the requested Principal when has access to do it.

        :param id: The resource ID. Required.
        :type id: str
        :return: Principal
        :rtype: ~kuflow.client.models.Principal
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Principal] = kwargs.pop("cls", None)

        request = build_retrieve_principal_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.DefaultError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Principal", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def find_processes(
        self, *, size: int = 25, page: int = 0, sort: Optional[List[str]] = None, **kwargs: Any
    ) -> _models.ProcessPage:
        """Find all accessible Processes.

        List all the Processes that have been created and the credentials has access.

        Available sort query values: id, createdAt, lastModifiedAt.

        :keyword size: The number of records returned within a single API call. Default value is 25.
        :paramtype size: int
        :keyword page: The page number of the current page in the returned records, 0 is the first
         page. Default value is 0.
        :paramtype page: int
        :keyword sort: Sorting criteria in the format: property{,asc|desc}. Example: createdAt,desc

         Default sort order is ascending. Multiple sort criteria are supported.

         Please refer to the method description for supported properties. Default value is None.
        :paramtype sort: list[str]
        :return: ProcessPage
        :rtype: ~kuflow.client.models.ProcessPage
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ProcessPage] = kwargs.pop("cls", None)

        request = build_find_processes_request(
            size=size,
            page=page,
            sort=sort,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.DefaultError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ProcessPage", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def create_process(
        self, process: _models.Process, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Process:
        """Create a new process.

        Creates a process. This option has direct correspondence to the action of starting a process in
        the Kuflow GUI.

        When a process is created, the current user is assigned as the process initiator, if you want
        to change it, you can pass a valid initiator using the following options:


        * If you know the ``principal ID`` you can assign it to ``initiator.id``
        * If you know the ``user ID`` you can assign it to ``initiator.user.id``
        * If you know the ``user email`` you can assign it to ``initiator.user.email``
        * If you know the ``application ID`` you can assign it to ``initiator.application.id``

        If you want the method to be idempotent, please specify the ``id`` field in the request body.

        :param process: Process to create. Required.
        :type process: ~kuflow.client.models.Process
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Process
        :rtype: ~kuflow.client.models.Process
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_process(
        self, process: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Process:
        """Create a new process.

        Creates a process. This option has direct correspondence to the action of starting a process in
        the Kuflow GUI.

        When a process is created, the current user is assigned as the process initiator, if you want
        to change it, you can pass a valid initiator using the following options:


        * If you know the ``principal ID`` you can assign it to ``initiator.id``
        * If you know the ``user ID`` you can assign it to ``initiator.user.id``
        * If you know the ``user email`` you can assign it to ``initiator.user.email``
        * If you know the ``application ID`` you can assign it to ``initiator.application.id``

        If you want the method to be idempotent, please specify the ``id`` field in the request body.

        :param process: Process to create. Required.
        :type process: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Process
        :rtype: ~kuflow.client.models.Process
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_process(self, process: Union[_models.Process, IO], **kwargs: Any) -> _models.Process:
        """Create a new process.

        Creates a process. This option has direct correspondence to the action of starting a process in
        the Kuflow GUI.

        When a process is created, the current user is assigned as the process initiator, if you want
        to change it, you can pass a valid initiator using the following options:


        * If you know the ``principal ID`` you can assign it to ``initiator.id``
        * If you know the ``user ID`` you can assign it to ``initiator.user.id``
        * If you know the ``user email`` you can assign it to ``initiator.user.email``
        * If you know the ``application ID`` you can assign it to ``initiator.application.id``

        If you want the method to be idempotent, please specify the ``id`` field in the request body.

        :param process: Process to create. Is either a model type or a IO type. Required.
        :type process: ~kuflow.client.models.Process or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: Process
        :rtype: ~kuflow.client.models.Process
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Process] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(process, (IO, bytes)):
            _content = process
        else:
            _json = self._serialize.body(process, "Process")

        request = build_create_process_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.DefaultError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if response.status_code == 200:
            deserialized = self._deserialize("Process", pipeline_response)

        if response.status_code == 201:
            deserialized = self._deserialize("Process", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def retrieve_process(self, id: str, **kwargs: Any) -> _models.Process:
        """Get a Process by ID.

        Returns the requested Process when has access to do it.

        :param id: The resource ID. Required.
        :type id: str
        :return: Process
        :rtype: ~kuflow.client.models.Process
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Process] = kwargs.pop("cls", None)

        request = build_retrieve_process_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.DefaultError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Process", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def actions_process_change_initiator(
        self,
        id: str,
        command: _models.ProcessChangeInitiatorCommand,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Process:
        """Change process initiator.

        Change the current initiator of a process.

        Allows you to choose a user (by email or principal identifier) or an application (principal
        identifier).
        Only one option will be necessary.

        :param id: The resource ID. Required.
        :type id: str
        :param command: Command to change the process initiator. Required.
        :type command: ~kuflow.client.models.ProcessChangeInitiatorCommand
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Process
        :rtype: ~kuflow.client.models.Process
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def actions_process_change_initiator(
        self, id: str, command: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Process:
        """Change process initiator.

        Change the current initiator of a process.

        Allows you to choose a user (by email or principal identifier) or an application (principal
        identifier).
        Only one option will be necessary.

        :param id: The resource ID. Required.
        :type id: str
        :param command: Command to change the process initiator. Required.
        :type command: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Process
        :rtype: ~kuflow.client.models.Process
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def actions_process_change_initiator(
        self, id: str, command: Union[_models.ProcessChangeInitiatorCommand, IO], **kwargs: Any
    ) -> _models.Process:
        """Change process initiator.

        Change the current initiator of a process.

        Allows you to choose a user (by email or principal identifier) or an application (principal
        identifier).
        Only one option will be necessary.

        :param id: The resource ID. Required.
        :type id: str
        :param command: Command to change the process initiator. Is either a model type or a IO type.
         Required.
        :type command: ~kuflow.client.models.ProcessChangeInitiatorCommand or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: Process
        :rtype: ~kuflow.client.models.Process
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Process] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(command, (IO, bytes)):
            _content = command
        else:
            _json = self._serialize.body(command, "ProcessChangeInitiatorCommand")

        request = build_actions_process_change_initiator_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.DefaultError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Process", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def actions_process_save_element(
        self,
        id: str,
        command: _models.ProcessSaveElementCommand,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Process:
        """Save a process element, aka: metadata.

        Allow to save an element.

        If values already exist for the provided element code, it replaces them with the new ones,
        otherwise it creates them. The values of the previous elements that no longer exist will be
        deleted.

        If the process is already finished the invocations fails with an error.

        :param id: The resource ID. Required.
        :type id: str
        :param command: Command to save an element. Required.
        :type command: ~kuflow.client.models.ProcessSaveElementCommand
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Process
        :rtype: ~kuflow.client.models.Process
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def actions_process_save_element(
        self, id: str, command: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Process:
        """Save a process element, aka: metadata.

        Allow to save an element.

        If values already exist for the provided element code, it replaces them with the new ones,
        otherwise it creates them. The values of the previous elements that no longer exist will be
        deleted.

        If the process is already finished the invocations fails with an error.

        :param id: The resource ID. Required.
        :type id: str
        :param command: Command to save an element. Required.
        :type command: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Process
        :rtype: ~kuflow.client.models.Process
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def actions_process_save_element(
        self, id: str, command: Union[_models.ProcessSaveElementCommand, IO], **kwargs: Any
    ) -> _models.Process:
        """Save a process element, aka: metadata.

        Allow to save an element.

        If values already exist for the provided element code, it replaces them with the new ones,
        otherwise it creates them. The values of the previous elements that no longer exist will be
        deleted.

        If the process is already finished the invocations fails with an error.

        :param id: The resource ID. Required.
        :type id: str
        :param command: Command to save an element. Is either a model type or a IO type. Required.
        :type command: ~kuflow.client.models.ProcessSaveElementCommand or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: Process
        :rtype: ~kuflow.client.models.Process
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Process] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(command, (IO, bytes)):
            _content = command
        else:
            _json = self._serialize.body(command, "ProcessSaveElementCommand")

        request = build_actions_process_save_element_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.DefaultError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Process", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def actions_process_delete_element(
        self,
        id: str,
        command: _models.ProcessDeleteElementCommand,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Process:
        """Delete an element by code.

        Allow to delete a process element by specifying the item definition code.

        Remove all the element values.

        :param id: The resource ID. Required.
        :type id: str
        :param command: Command to delete an element. Required.
        :type command: ~kuflow.client.models.ProcessDeleteElementCommand
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Process
        :rtype: ~kuflow.client.models.Process
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def actions_process_delete_element(
        self, id: str, command: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Process:
        """Delete an element by code.

        Allow to delete a process element by specifying the item definition code.

        Remove all the element values.

        :param id: The resource ID. Required.
        :type id: str
        :param command: Command to delete an element. Required.
        :type command: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Process
        :rtype: ~kuflow.client.models.Process
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def actions_process_delete_element(
        self, id: str, command: Union[_models.ProcessDeleteElementCommand, IO], **kwargs: Any
    ) -> _models.Process:
        """Delete an element by code.

        Allow to delete a process element by specifying the item definition code.

        Remove all the element values.

        :param id: The resource ID. Required.
        :type id: str
        :param command: Command to delete an element. Is either a model type or a IO type. Required.
        :type command: ~kuflow.client.models.ProcessDeleteElementCommand or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: Process
        :rtype: ~kuflow.client.models.Process
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Process] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(command, (IO, bytes)):
            _content = command
        else:
            _json = self._serialize.body(command, "ProcessDeleteElementCommand")

        request = build_actions_process_delete_element_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.DefaultError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Process", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def actions_process_complete(self, id: str, **kwargs: Any) -> _models.Process:
        """Complete a Process.

        Complete a Process. The state of Process is set to 'completed'.

        If you are already in this state, no action is taken.

        :param id: The resource ID. Required.
        :type id: str
        :return: Process
        :rtype: ~kuflow.client.models.Process
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Process] = kwargs.pop("cls", None)

        request = build_actions_process_complete_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.DefaultError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Process", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def actions_process_cancel(self, id: str, **kwargs: Any) -> _models.Process:
        """Cancel a Process.

        Cancel a Process. The Process state is set to 'cancelled'.

        All the active tasks will be marked as cancelled too.

        If you are already in this state, no action is taken.

        :param id: The resource ID. Required.
        :type id: str
        :return: Process
        :rtype: ~kuflow.client.models.Process
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Process] = kwargs.pop("cls", None)

        request = build_actions_process_cancel_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.DefaultError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Process", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def actions_process_save_user_action_value_document(
        self, id: str, file: IO, *, file_content_type: str, file_name: str, user_action_value_id: str, **kwargs: Any
    ) -> Optional[_models.Process]:
        """Upload and save a document in a user action.

        Allow saving a user action document uploading the content.

        :param id: The resource ID. Required.
        :type id: str
        :param file: Document to save. Required.
        :type file: IO
        :keyword file_content_type: Document content type. Required.
        :paramtype file_content_type: str
        :keyword file_name: Document name. Required.
        :paramtype file_name: str
        :keyword user_action_value_id: User action value ID related to de document. Required.
        :paramtype user_action_value_id: str
        :return: Process or None
        :rtype: ~kuflow.client.models.Process or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/octet-stream"))
        cls: ClsType[Optional[_models.Process]] = kwargs.pop("cls", None)

        _content = file

        request = build_actions_process_save_user_action_value_document_request(
            id=id,
            file_content_type=file_content_type,
            file_name=file_name,
            user_action_value_id=user_action_value_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 304]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize("Process", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def find_tasks(
        self,
        *,
        size: int = 25,
        page: int = 0,
        sort: Optional[List[str]] = None,
        process_id: Optional[List[str]] = None,
        state: Optional[List[Union[str, _models.TaskState]]] = None,
        task_definition_code: Optional[List[str]] = None,
        **kwargs: Any
    ) -> _models.TaskPage:
        """Find all accessible Tasks.

        List all Tasks that have been created and the credentials has access.

        Available sort query values: id, createdAt, lastModifiedAt, claimedAt, completedAt,
        cancelledAt.

        :keyword size: The number of records returned within a single API call. Default value is 25.
        :paramtype size: int
        :keyword page: The page number of the current page in the returned records, 0 is the first
         page. Default value is 0.
        :paramtype page: int
        :keyword sort: Sorting criteria in the format: property{,asc|desc}. Example: createdAt,desc

         Default sort order is ascending. Multiple sort criteria are supported.

         Please refer to the method description for supported properties. Default value is None.
        :paramtype sort: list[str]
        :keyword process_id: Filter by an array of process ids. Default value is None.
        :paramtype process_id: list[str]
        :keyword state: Filter by an array of task states. Default value is None.
        :paramtype state: list[str or ~kuflow.client.models.TaskState]
        :keyword task_definition_code: Filter by an array of task definition codes. Default value is
         None.
        :paramtype task_definition_code: list[str]
        :return: TaskPage
        :rtype: ~kuflow.client.models.TaskPage
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TaskPage] = kwargs.pop("cls", None)

        request = build_find_tasks_request(
            size=size,
            page=page,
            sort=sort,
            process_id=process_id,
            state=state,
            task_definition_code=task_definition_code,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.DefaultError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("TaskPage", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def create_task(
        self,
        task: _models.Task,
        *,
        activity_token: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Task:
        """Create a new Task in the selected Process.

        Create a Task and optionally fill its elements. We can fill in any type of element except
        documents.

        If you want to add document type elements, you can pass a reference to an existing document
        type element indicating its 'uri'. This will copy that document into the element. In case you
        want to add a new document, please use the corresponding API method.

        If you want that the task created is claimed you can a valid owner using the following options:


        * If you know the ``principal ID`` you can assign it to ``owner.id``
        * If you know the ``user ID`` you can assign it to ``owner.user.id``
        * If you know the ``user email`` you can assign it to ``owner.user.email``
        * If you know the ``application ID`` you can assign it to ``owner.application.id``

        If you want the method to be idempotent, please specify the ``id`` field in the request body.

        :param task: Task to be created. Required.
        :type task: ~kuflow.client.models.Task
        :keyword activity_token: When create a Kuflow Task backed with a Temporal.io servers, this
         value is required and must be set with the context task token of Temporal.io activity. Default
         value is None.
        :paramtype activity_token: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Task
        :rtype: ~kuflow.client.models.Task
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_task(
        self, task: IO, *, activity_token: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Task:
        """Create a new Task in the selected Process.

        Create a Task and optionally fill its elements. We can fill in any type of element except
        documents.

        If you want to add document type elements, you can pass a reference to an existing document
        type element indicating its 'uri'. This will copy that document into the element. In case you
        want to add a new document, please use the corresponding API method.

        If you want that the task created is claimed you can a valid owner using the following options:


        * If you know the ``principal ID`` you can assign it to ``owner.id``
        * If you know the ``user ID`` you can assign it to ``owner.user.id``
        * If you know the ``user email`` you can assign it to ``owner.user.email``
        * If you know the ``application ID`` you can assign it to ``owner.application.id``

        If you want the method to be idempotent, please specify the ``id`` field in the request body.

        :param task: Task to be created. Required.
        :type task: IO
        :keyword activity_token: When create a Kuflow Task backed with a Temporal.io servers, this
         value is required and must be set with the context task token of Temporal.io activity. Default
         value is None.
        :paramtype activity_token: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Task
        :rtype: ~kuflow.client.models.Task
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_task(
        self, task: Union[_models.Task, IO], *, activity_token: Optional[str] = None, **kwargs: Any
    ) -> _models.Task:
        """Create a new Task in the selected Process.

        Create a Task and optionally fill its elements. We can fill in any type of element except
        documents.

        If you want to add document type elements, you can pass a reference to an existing document
        type element indicating its 'uri'. This will copy that document into the element. In case you
        want to add a new document, please use the corresponding API method.

        If you want that the task created is claimed you can a valid owner using the following options:


        * If you know the ``principal ID`` you can assign it to ``owner.id``
        * If you know the ``user ID`` you can assign it to ``owner.user.id``
        * If you know the ``user email`` you can assign it to ``owner.user.email``
        * If you know the ``application ID`` you can assign it to ``owner.application.id``

        If you want the method to be idempotent, please specify the ``id`` field in the request body.

        :param task: Task to be created. Is either a model type or a IO type. Required.
        :type task: ~kuflow.client.models.Task or IO
        :keyword activity_token: When create a Kuflow Task backed with a Temporal.io servers, this
         value is required and must be set with the context task token of Temporal.io activity. Default
         value is None.
        :paramtype activity_token: str
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: Task
        :rtype: ~kuflow.client.models.Task
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Task] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(task, (IO, bytes)):
            _content = task
        else:
            _json = self._serialize.body(task, "Task")

        request = build_create_task_request(
            activity_token=activity_token,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.DefaultError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if response.status_code == 200:
            deserialized = self._deserialize("Task", pipeline_response)

        if response.status_code == 201:
            deserialized = self._deserialize("Task", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def retrieve_task(self, id: str, **kwargs: Any) -> _models.Task:
        """Get a task given it ID.

        Allow to get a task by ID.

        :param id: The resource ID. Required.
        :type id: str
        :return: Task
        :rtype: ~kuflow.client.models.Task
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Task] = kwargs.pop("cls", None)

        request = build_retrieve_task_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("Task", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def actions_task_claim(self, id: str, **kwargs: Any) -> _models.Task:
        """Claim a task.

        Allow to claim a task.

        :param id: The resource ID. Required.
        :type id: str
        :return: Task
        :rtype: ~kuflow.client.models.Task
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Task] = kwargs.pop("cls", None)

        request = build_actions_task_claim_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.DefaultError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Task", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def actions_task_assign(
        self, id: str, command: _models.TaskAssignCommand, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Task:
        """Assign a task.

        Allow to assign a task to a user or application. Only one option will be necessary.

        :param id: The resource ID. Required.
        :type id: str
        :param command: Command to change the task owner. Required.
        :type command: ~kuflow.client.models.TaskAssignCommand
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Task
        :rtype: ~kuflow.client.models.Task
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def actions_task_assign(
        self, id: str, command: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Task:
        """Assign a task.

        Allow to assign a task to a user or application. Only one option will be necessary.

        :param id: The resource ID. Required.
        :type id: str
        :param command: Command to change the task owner. Required.
        :type command: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Task
        :rtype: ~kuflow.client.models.Task
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def actions_task_assign(
        self, id: str, command: Union[_models.TaskAssignCommand, IO], **kwargs: Any
    ) -> _models.Task:
        """Assign a task.

        Allow to assign a task to a user or application. Only one option will be necessary.

        :param id: The resource ID. Required.
        :type id: str
        :param command: Command to change the task owner. Is either a model type or a IO type.
         Required.
        :type command: ~kuflow.client.models.TaskAssignCommand or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: Task
        :rtype: ~kuflow.client.models.Task
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Task] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(command, (IO, bytes)):
            _content = command
        else:
            _json = self._serialize.body(command, "TaskAssignCommand")

        request = build_actions_task_assign_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.DefaultError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Task", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def actions_task_save_element(
        self, id: str, command: _models.TaskSaveElementCommand, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Task:
        """Save an element.

        Allow to save an element i.e., a field, a decision, a form, a principal or document.

        In the case of document type elements, this method only allows references to be made to other
        existing document type elements for the purpose of copying that file into the element. To do
        this you need to pass a reference to the document using the 'uri' attribute. In case you want
        to add a new document, please use the corresponding API method. If values already exist for the
        provided element code, it replaces them with the new ones, otherwise it creates them. The
        values of the previous elements that no longer exist will be deleted. To remove an element, use
        the appropriate API method.

        :param id: The resource ID. Required.
        :type id: str
        :param command: Command to save an element. Required.
        :type command: ~kuflow.client.models.TaskSaveElementCommand
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Task
        :rtype: ~kuflow.client.models.Task
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def actions_task_save_element(
        self, id: str, command: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Task:
        """Save an element.

        Allow to save an element i.e., a field, a decision, a form, a principal or document.

        In the case of document type elements, this method only allows references to be made to other
        existing document type elements for the purpose of copying that file into the element. To do
        this you need to pass a reference to the document using the 'uri' attribute. In case you want
        to add a new document, please use the corresponding API method. If values already exist for the
        provided element code, it replaces them with the new ones, otherwise it creates them. The
        values of the previous elements that no longer exist will be deleted. To remove an element, use
        the appropriate API method.

        :param id: The resource ID. Required.
        :type id: str
        :param command: Command to save an element. Required.
        :type command: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Task
        :rtype: ~kuflow.client.models.Task
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def actions_task_save_element(
        self, id: str, command: Union[_models.TaskSaveElementCommand, IO], **kwargs: Any
    ) -> _models.Task:
        """Save an element.

        Allow to save an element i.e., a field, a decision, a form, a principal or document.

        In the case of document type elements, this method only allows references to be made to other
        existing document type elements for the purpose of copying that file into the element. To do
        this you need to pass a reference to the document using the 'uri' attribute. In case you want
        to add a new document, please use the corresponding API method. If values already exist for the
        provided element code, it replaces them with the new ones, otherwise it creates them. The
        values of the previous elements that no longer exist will be deleted. To remove an element, use
        the appropriate API method.

        :param id: The resource ID. Required.
        :type id: str
        :param command: Command to save an element. Is either a model type or a IO type. Required.
        :type command: ~kuflow.client.models.TaskSaveElementCommand or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: Task
        :rtype: ~kuflow.client.models.Task
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Task] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(command, (IO, bytes)):
            _content = command
        else:
            _json = self._serialize.body(command, "TaskSaveElementCommand")

        request = build_actions_task_save_element_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.DefaultError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Task", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def actions_task_save_element_value_document(
        self,
        id: str,
        file: IO,
        *,
        file_content_type: str,
        file_name: str,
        element_definition_code: str,
        element_value_id: Optional[str] = None,
        element_value_valid: bool = True,
        **kwargs: Any
    ) -> _models.Task:
        """Save an element document.

        Allow to save an element document uploading the content.

        If it is a multiple element, and the ID referenced in the body does not exist or is empty, the
        document will be added to the element. If the element already exists (the ID referenced in the
        body corresponds to an existing one), it updates it.

        :param id: The resource ID. Required.
        :type id: str
        :param file: Command to save a document element value. Required.
        :type file: IO
        :keyword file_content_type: Document content type. Required.
        :paramtype file_content_type: str
        :keyword file_name: Document name. Required.
        :paramtype file_name: str
        :keyword element_definition_code: Element Definition Code. Required.
        :paramtype element_definition_code: str
        :keyword element_value_id: Element Value ID. Default value is None.
        :paramtype element_value_id: str
        :keyword element_value_valid: Element Value ID. Default value is True.
        :paramtype element_value_valid: bool
        :return: Task
        :rtype: ~kuflow.client.models.Task
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/octet-stream"))
        cls: ClsType[_models.Task] = kwargs.pop("cls", None)

        _content = file

        request = build_actions_task_save_element_value_document_request(
            id=id,
            file_content_type=file_content_type,
            file_name=file_name,
            element_definition_code=element_definition_code,
            element_value_id=element_value_id,
            element_value_valid=element_value_valid,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("Task", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def actions_task_delete_element(
        self,
        id: str,
        command: _models.TaskDeleteElementCommand,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Task:
        """Delete an element by code.

        Allow to delete task element by specifying the item definition code.

        Remove all the element values.

        :param id: The resource ID. Required.
        :type id: str
        :param command: Command to delete an element. Required.
        :type command: ~kuflow.client.models.TaskDeleteElementCommand
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Task
        :rtype: ~kuflow.client.models.Task
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def actions_task_delete_element(
        self, id: str, command: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Task:
        """Delete an element by code.

        Allow to delete task element by specifying the item definition code.

        Remove all the element values.

        :param id: The resource ID. Required.
        :type id: str
        :param command: Command to delete an element. Required.
        :type command: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Task
        :rtype: ~kuflow.client.models.Task
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def actions_task_delete_element(
        self, id: str, command: Union[_models.TaskDeleteElementCommand, IO], **kwargs: Any
    ) -> _models.Task:
        """Delete an element by code.

        Allow to delete task element by specifying the item definition code.

        Remove all the element values.

        :param id: The resource ID. Required.
        :type id: str
        :param command: Command to delete an element. Is either a model type or a IO type. Required.
        :type command: ~kuflow.client.models.TaskDeleteElementCommand or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: Task
        :rtype: ~kuflow.client.models.Task
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Task] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(command, (IO, bytes)):
            _content = command
        else:
            _json = self._serialize.body(command, "TaskDeleteElementCommand")

        request = build_actions_task_delete_element_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.DefaultError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Task", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def actions_task_delete_element_value_document(
        self,
        id: str,
        command: _models.TaskDeleteElementValueDocumentCommand,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Task:
        """Delete an element document value.

        Allow to delete a specific document from an element of document type using its id.

        Note: If it is a multiple item, it will only delete the specified document. If it is a single
        element, in addition to the document, it will also delete the element.

        :param id: The resource ID. Required.
        :type id: str
        :param command: Command to delete a document elemente value. Required.
        :type command: ~kuflow.client.models.TaskDeleteElementValueDocumentCommand
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Task
        :rtype: ~kuflow.client.models.Task
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def actions_task_delete_element_value_document(
        self, id: str, command: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Task:
        """Delete an element document value.

        Allow to delete a specific document from an element of document type using its id.

        Note: If it is a multiple item, it will only delete the specified document. If it is a single
        element, in addition to the document, it will also delete the element.

        :param id: The resource ID. Required.
        :type id: str
        :param command: Command to delete a document elemente value. Required.
        :type command: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Task
        :rtype: ~kuflow.client.models.Task
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def actions_task_delete_element_value_document(
        self, id: str, command: Union[_models.TaskDeleteElementValueDocumentCommand, IO], **kwargs: Any
    ) -> _models.Task:
        """Delete an element document value.

        Allow to delete a specific document from an element of document type using its id.

        Note: If it is a multiple item, it will only delete the specified document. If it is a single
        element, in addition to the document, it will also delete the element.

        :param id: The resource ID. Required.
        :type id: str
        :param command: Command to delete a document elemente value. Is either a model type or a IO
         type. Required.
        :type command: ~kuflow.client.models.TaskDeleteElementValueDocumentCommand or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: Task
        :rtype: ~kuflow.client.models.Task
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Task] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(command, (IO, bytes)):
            _content = command
        else:
            _json = self._serialize.body(command, "TaskDeleteElementValueDocumentCommand")

        request = build_actions_task_delete_element_value_document_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.DefaultError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Task", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def actions_task_download_element_value_document(
        self, id: str, *, document_id: str, **kwargs: Any
    ) -> AsyncIterator[bytes]:
        """Download document.

        Given a task, download a document from an element of document type.

        :param id: The resource ID. Required.
        :type id: str
        :keyword document_id: Document ID to download. Required.
        :paramtype document_id: str
        :return: Async iterator of the response bytes
        :rtype: AsyncIterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        request = build_actions_task_download_element_value_document_request(
            id=id,
            document_id=document_id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=True, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def actions_task_download_element_value_rendered(
        self, id: str, *, element_definition_code: str, **kwargs: Any
    ) -> AsyncIterator[bytes]:
        """Download a Form rendered as PDF or Zip of PDFs (when the element is multiple).

        Given a task, generate a PDF from a Form type element with the data filled in, if any. If there
        are multiple form values, they are packed into a ZIP.

        Important!: To use this feature, please contact to kuflow@kuflow.com.

        :param id: The resource ID. Required.
        :type id: str
        :keyword element_definition_code: Element definition code of a Form Element to download.
         Required.
        :paramtype element_definition_code: str
        :return: Async iterator of the response bytes
        :rtype: AsyncIterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        request = build_actions_task_download_element_value_rendered_request(
            id=id,
            element_definition_code=element_definition_code,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=True, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def actions_task_complete(self, id: str, **kwargs: Any) -> _models.Task:
        """Complete a task.

        Allow to complete a claimed task by the principal.

        :param id: The resource ID. Required.
        :type id: str
        :return: Task
        :rtype: ~kuflow.client.models.Task
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Task] = kwargs.pop("cls", None)

        request = build_actions_task_complete_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("Task", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def actions_task_append_log(
        self, id: str, log: _models.Log, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Task:
        """Append a log to the task.

        A log entry is added to the task. If the number of log entries is reached, the oldest log entry
        is removed.

        :param id: The resource ID. Required.
        :type id: str
        :param log: Log to be created. Required.
        :type log: ~kuflow.client.models.Log
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Task
        :rtype: ~kuflow.client.models.Task
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def actions_task_append_log(
        self, id: str, log: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Task:
        """Append a log to the task.

        A log entry is added to the task. If the number of log entries is reached, the oldest log entry
        is removed.

        :param id: The resource ID. Required.
        :type id: str
        :param log: Log to be created. Required.
        :type log: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Task
        :rtype: ~kuflow.client.models.Task
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def actions_task_append_log(self, id: str, log: Union[_models.Log, IO], **kwargs: Any) -> _models.Task:
        """Append a log to the task.

        A log entry is added to the task. If the number of log entries is reached, the oldest log entry
        is removed.

        :param id: The resource ID. Required.
        :type id: str
        :param log: Log to be created. Is either a model type or a IO type. Required.
        :type log: ~kuflow.client.models.Log or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: Task
        :rtype: ~kuflow.client.models.Task
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Task] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(log, (IO, bytes)):
            _content = log
        else:
            _json = self._serialize.body(log, "Log")

        request = build_actions_task_append_log_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("Task", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
